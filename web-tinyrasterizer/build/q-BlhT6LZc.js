class z{constructor(t=0,s=0){this.x=t,this.y=s}get length(){return Math.hypot(this.x,this.y)}add(t){return new z(this.x+t.x,this.y+t.y)}sub(t){return new z(this.x-t.x,this.y-t.y)}scale(t){return new z(this.x*t,this.y*t)}normalize(){const t=this.length;return t===0?new z:this.scale(1/t)}dot(t){return this.x*t.x+this.y*t.y}static zero(){return new z(0,0)}}class u{constructor(t=0,s=0,e=0){this.x=t,this.y=s,this.z=e}get length(){return Math.hypot(this.x,this.y,this.z)}add(t){return new u(this.x+t.x,this.y+t.y,this.z+t.z)}sub(t){return new u(this.x-t.x,this.y-t.y,this.z-t.z)}scale(t){return new u(this.x*t,this.y*t,this.z*t)}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){return new u(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}normalize(){const t=this.length;return t===0?new u:this.scale(1/t)}static zero(){return new u(0,0,0)}}class p{constructor(t=0,s=0,e=0,n=0){this.x=t,this.y=s,this.z=e,this.w=n}get length(){return Math.hypot(this.x,this.y,this.z,this.w)}normalize(){const t=this.length;return t===0?new p:this.scale(1/t)}scale(t){return new p(this.x*t,this.y*t,this.z*t,this.w*t)}perspectiveDivide(){return new u(this.x/this.w,this.y/this.w,this.z/this.w)}static fromVector3(t,s=1){return new p(t.x,t.y,t.z,s)}toVec3(){return new u(this.x,this.y,this.z)}}class g{constructor(t,s,e){if(this.rows=t,this.cols=s,this.elements=e,e.length!==t*s)throw new Error("Invalid element count")}static identity(t){const s=new Array(t*t).fill(0);for(let e=0;e<t;e++)s[e*t+e]=1;return new g(t,t,s)}static fromRows(...t){const s=t.length,e=t[0].length;return new g(s,e,t.flat())}get(t,s){return this.elements[t*this.cols+s]}multiply(t){if(this.cols!==t.rows)throw new Error("Matrix dimension mismatch");const s=new Array(this.rows*t.cols).fill(0);for(let e=0;e<this.rows;e++)for(let n=0;n<t.cols;n++){let o=0;for(let i=0;i<this.cols;i++)o+=this.get(e,i)*t.get(i,n);s[e*t.cols+n]=o}return new g(this.rows,t.cols,s)}transpose(){const t=new Array(this.rows*this.cols);for(let s=0;s<this.rows;s++)for(let e=0;e<this.cols;e++)t[e*this.rows+s]=this.get(s,e);return new g(this.cols,this.rows,t)}multiplyVector4(t){if(this.rows!==4||this.cols!==4)throw new Error("Matrix must be 4x4");const s=this.elements;return new p(s[0]*t.x+s[1]*t.y+s[2]*t.z+s[3]*t.w,s[4]*t.x+s[5]*t.y+s[6]*t.z+s[7]*t.w,s[8]*t.x+s[9]*t.y+s[10]*t.z+s[11]*t.w,s[12]*t.x+s[13]*t.y+s[14]*t.z+s[15]*t.w)}multiplyVector3(t){if(this.rows!==3||this.cols!==3)throw new Error("Matrix must be 3x3");return new u(this.get(0,0)*t.x+this.get(0,1)*t.y+this.get(0,2)*t.z,this.get(1,0)*t.x+this.get(1,1)*t.y+this.get(1,2)*t.z,this.get(2,0)*t.x+this.get(2,1)*t.y+this.get(2,2)*t.z)}invert(){if(this.rows!==this.cols)throw new Error("Matrix must be square to invert");const t=this.rows,s=this.det();if(s===0)return null;const e=new Array(t*t);for(let n=0;n<t;n++)for(let o=0;o<t;o++)e[o*t+n]=this.cofactor(n,o);for(let n=0;n<e.length;n++)e[n]/=s;return new g(t,t,e)}invertTranspose(){const t=this.invert();return t?t.transpose():null}det(){if(this.rows!==this.cols)throw new Error("Determinant is only defined for square matrices");const t=this.rows;if(t===1)return this.elements[0];if(t===2)return this.get(0,0)*this.get(1,1)-this.get(0,1)*this.get(1,0);let s=0;for(let e=0;e<t;e++)s+=this.get(0,e)*this.cofactor(0,e);return s}cofactor(t,s){const e=[];for(let i=0;i<this.rows;i++)if(i!==t)for(let r=0;r<this.cols;r++)r!==s&&e.push(this.get(i,r));const n=new g(this.rows-1,this.cols-1,e);return((t+s)%2===0?1:-1)*n.det()}}class T{static lookAt(t,s,e){const n=t.sub(s).normalize(),o=e.cross(n).normalize(),i=n.cross(o);return g.fromRows([o.x,o.y,o.z,-o.dot(t)],[i.x,i.y,i.z,-i.dot(t)],[n.x,n.y,n.z,-n.dot(t)],[0,0,0,1])}static perspective(t,s,e,n){const o=1/Math.tan(t*Math.PI/360);return g.fromRows([o/s,0,0,0],[0,o,0,0],[0,0,(n+e)/(e-n),2*n*e/(e-n)],[0,0,-1,0])}static viewport(t,s,e,n){return g.fromRows([e/2,0,0,t+e/2],[0,-n/2,0,s+n/2],[0,0,1,0],[0,0,0,1])}}function k(m,t){const s=m.map(()=>new u(0,0,0));for(const e of t){const[n,o,i]=e.v,r=m[n],l=m[o],M=m[i],h=l.sub(r),x=M.sub(r),w=h.cross(x).normalize();s[n].add(w),s[o].add(w),s[i].add(w)}for(const e of s)e.normalize();return s}function X(m){const t=[],s=[],e=[],n=[],o=m.split(`
`);for(const i of o){const r=i.trim();if(!r||r.startsWith("#"))continue;const l=r.split(/\s+/);switch(l[0]){case"v":t.push(new u(+l[1],+l[2],+l[3]));break;case"vt":s.push(new z(+l[1],1-+l[2]));break;case"vn":{const h=+l[1],x=+l[2],w=+l[3],c=Math.hypot(h,x,w)||1;e.push(new u(h/c,x/c,w/c));break}case"f":{const h=[],x=[],w=[];for(const c of l.slice(1)){const[y,a,f]=c.split("/");y&&h.push(parseInt(y)-1),a&&x.push(parseInt(a)-1),f&&w.push(parseInt(f)-1)}if(h.length<3)break;for(let c=1;c<h.length-1;c++)n.push({v:[h[0],h[c],h[c+1]],vt:x.length?[x[0],x[c],x[c+1]]:void 0,vn:w.length?[w[0],w[c],w[c+1]]:void 0});break}}}if(e.length===0){const i=k(t,n);e.push(...i);for(const r of n)r.vn=[...r.v]}return new A(t,s,e,n)}class A{constructor(t,s,e,n){this.vertices=t,this.texCoords=s,this.normals=e,this.faces=n}nfaces(){return this.faces.length}nvertices(){return this.vertices.length}getVert(t,s){return s===void 0?this.vertices[t]:this.vertices[this.faces[t].v[s]]}getUV(t,s){const e=this.faces[t];return!e.vt||e.vt[s]===void 0?new z(0,0):this.texCoords[e.vt[s]]}getNormal(t,s){const e=this.faces[t];if(!e.vn)throw new Error("No normals");return this.normals[e.vn[s]]}sampleDiffuse(t){return{r:128,g:128,b:128,a:255}}}class E{constructor(t){this.settings={ctx:null},this.settings.ctx=t.ctx}createImageFromContext(t,s){if(!this.settings.ctx){console.error("CTXImage > CTX is null ");return}return this.settings.ctx.createImageData(t,s)}}let I;function N(m,t){I=new Float32Array(m*t),I.fill(-1e3)}function B(m,t,s,e,n,o){const i=[t[0].scale(1/t[0].w),t[1].scale(1/t[1].w),t[2].scale(1/t[2].w)],r=i.map(a=>{const f=m.viewport.multiplyVector4(a);return new z(f.x,f.y)}),l=g.fromRows([r[0].x,r[1].x,r[2].x],[r[0].y,r[1].y,r[2].y],[1,1,1]);if(l.det()<1e-4)return;const[h,x]=[Math.min(r[0].x,r[1].x,r[2].x),Math.max(r[0].x,r[1].x,r[2].x)],[w,c]=[Math.min(r[0].y,r[1].y,r[2].y),Math.max(r[0].y,r[1].y,r[2].y)],y=l.invert();for(let a=Math.max(Math.floor(h),0);a<=Math.min(Math.floor(x),n-1);a++)for(let f=Math.max(Math.floor(w),0);f<=Math.min(Math.floor(c),o-1);f++){const d=y.multiplyVector3(new u(a,f,1));if(d.x<0||d.y<0||d.z<0)continue;const b=new u(d.x/t[0].w,d.y/t[1].w,d.z/t[2].w),D=b.x+b.y+b.z;b.x/=D,b.y/=D,b.z/=D;const V=d.x*i[0].z+d.y*i[1].z+d.z*i[2].z,F=a+f*n;if(V<I[F])continue;const C=s.fragment(b);I[F]=V;const v=(a+f*n)*4;e[v+0]=C.r,e[v+1]=C.g,e[v+2]=C.b,e[v+3]=255}}class P{}class R extends P{constructor(t,s,e,n){super(),this.model=t,this.modelViewMatrix=s,this.projectionMatrix=n,this.lightDirection=s.multiplyVector4(new p(e.x,e.y,e.z,0)).normalize(),this.normalMatrix=this.modelViewMatrix.invertTranspose(),this.vertexToFragmentData={uv:[],normals:[],tri:[]}}vertex(t,s){const e=this.model.getNormal(t,s).normalize(),n=new p(e.x,e.y,e.z,0),o=this.model.getVert(t,s),i=new p(o.x,o.y,o.z,1);this.vertexToFragmentData.uv[s]=this.model.getUV(t,s),this.vertexToFragmentData.normals[s]=this.normalMatrix.multiplyVector4(n.normalize()).toVec3();const r=this.modelViewMatrix.multiplyVector4(i);return this.vertexToFragmentData.tri[s]=r.toVec3(),this.projectionMatrix.multiplyVector4(r)}fragment(t){const s=this.vertexToFragmentData.normals[0].scale(t.x).add(this.vertexToFragmentData.normals[1].scale(t.y)).add(this.vertexToFragmentData.normals[2].scale(t.z)).normalize(),e=this.lightDirection.normalize(),n=new p(0,0,-1,0),o=Math.max(0,s.dot(e.toVec3())),i=s.scale(2*o).sub(e.toVec3()).normalize(),r=.3,l=.7*o,M=.5*Math.pow(Math.max(i.dot(n.toVec3()),0),35),h=Math.min(1,r+l+M),x={r:255,g:255,b:255};return{r:Math.min(255,x.r*h),g:Math.min(255,x.g*h),b:Math.min(255,x.b*h),a:255}}}function q(m,t,s,e){s=s||800,e=e||800;const n=new u(1,1,1);let o=new u(5,0,-5);const i=new u(0,0,0),r=new u(0,1,0),l=T.lookAt(o,i,r),M=T.viewport(0,0,s,e),h=T.perspective(20,1,.1,100);console.log("Projection matrix:",h);const w=new E({ctx:m}).createImageFromContext(s,e),c=w.data,y=new R(t,l,n,h);N(s,e);for(let a=0;a<c.length;a+=4)c[a]=22,c[a+1]=22,c[a+2]=22,c[a+3]=255;for(let a=0;a<t.faces.length;a++){const f=[y.vertex(a,0),y.vertex(a,1),y.vertex(a,2)];B({viewport:M},f,y,c,s,e)}m.putImageData(w,0,0)}export{X as p,q as r};
