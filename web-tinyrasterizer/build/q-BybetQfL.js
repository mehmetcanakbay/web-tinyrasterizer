class v{constructor(t=0,s=0){this.x=t,this.y=s}get length(){return Math.hypot(this.x,this.y)}add(t){return new v(this.x+t.x,this.y+t.y)}sub(t){return new v(this.x-t.x,this.y-t.y)}scale(t){return new v(this.x*t,this.y*t)}normalize(){const t=this.length;return t===0?new v:this.scale(1/t)}dot(t){return this.x*t.x+this.y*t.y}static zero(){return new v(0,0)}}class a{constructor(t=0,s=0,e=0){this.x=t,this.y=s,this.z=e}get length(){return Math.hypot(this.x,this.y,this.z)}add(t){return new a(this.x+t.x,this.y+t.y,this.z+t.z)}sub(t){return new a(this.x-t.x,this.y-t.y,this.z-t.z)}scale(t){return new a(this.x*t,this.y*t,this.z*t)}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){return new a(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}normalize(){const t=this.length;return t===0?new a:this.scale(1/t)}static zero(){return new a(0,0,0)}}class I{constructor(t=0,s=0,e=0,n=0){this.x=t,this.y=s,this.z=e,this.w=n}get length(){return Math.hypot(this.x,this.y,this.z,this.w)}normalize(){const t=this.length;return t===0?new I:this.scale(1/t)}scale(t){return new I(this.x*t,this.y*t,this.z*t,this.w*t)}perspectiveDivide(){return new a(this.x/this.w,this.y/this.w,this.z/this.w)}static fromVector3(t,s=1){return new I(t.x,t.y,t.z,s)}toVec3(){return new a(this.x,this.y,this.z)}}class f{constructor(t,s,e){if(this.rows=t,this.cols=s,this.elements=e,e.length!==t*s)throw new Error("Invalid element count")}static identity(t){const s=new Array(t*t).fill(0);for(let e=0;e<t;e++)s[e*t+e]=1;return new f(t,t,s)}static fromRows(...t){const s=t.length,e=t[0].length;return new f(s,e,t.flat())}get(t,s){return this.elements[t*this.cols+s]}multiply(t){if(this.cols!==t.rows)throw new Error("Matrix dimension mismatch");const s=new Array(this.rows*t.cols).fill(0);for(let e=0;e<this.rows;e++)for(let n=0;n<t.cols;n++){let o=0;for(let i=0;i<this.cols;i++)o+=this.get(e,i)*t.get(i,n);s[e*t.cols+n]=o}return new f(this.rows,t.cols,s)}transpose(){const t=new Array(this.rows*this.cols);for(let s=0;s<this.rows;s++)for(let e=0;e<this.cols;e++)t[e*this.rows+s]=this.get(s,e);return new f(this.cols,this.rows,t)}multiplyVector4(t){if(this.rows!==4||this.cols!==4)throw new Error("Matrix must be 4x4");const s=this.elements;return new I(s[0]*t.x+s[1]*t.y+s[2]*t.z+s[3]*t.w,s[4]*t.x+s[5]*t.y+s[6]*t.z+s[7]*t.w,s[8]*t.x+s[9]*t.y+s[10]*t.z+s[11]*t.w,s[12]*t.x+s[13]*t.y+s[14]*t.z+s[15]*t.w)}multiplyVector3(t){if(this.rows!==3||this.cols!==3)throw new Error("Matrix must be 3x3");return new a(this.get(0,0)*t.x+this.get(0,1)*t.y+this.get(0,2)*t.z,this.get(1,0)*t.x+this.get(1,1)*t.y+this.get(1,2)*t.z,this.get(2,0)*t.x+this.get(2,1)*t.y+this.get(2,2)*t.z)}invert(){if(this.rows!==this.cols)throw new Error("Matrix must be square to invert");const t=this.rows,s=this.det();if(s===0)return null;const e=new Array(t*t);for(let n=0;n<t;n++)for(let o=0;o<t;o++)e[o*t+n]=this.cofactor(n,o);for(let n=0;n<e.length;n++)e[n]/=s;return new f(t,t,e)}invertTranspose(){const t=this.invert();return t?t.transpose():null}det(){if(this.rows!==this.cols)throw new Error("Determinant is only defined for square matrices");const t=this.rows;if(t===1)return this.elements[0];if(t===2)return this.get(0,0)*this.get(1,1)-this.get(0,1)*this.get(1,0);let s=0;for(let e=0;e<t;e++)s+=this.get(0,e)*this.cofactor(0,e);return s}cofactor(t,s){const e=[];for(let i=0;i<this.rows;i++)if(i!==t)for(let r=0;r<this.cols;r++)r!==s&&e.push(this.get(i,r));const n=new f(this.rows-1,this.cols-1,e);return((t+s)%2===0?1:-1)*n.det()}}class V{static lookAt(t,s,e){const n=t.sub(s).normalize(),o=e.cross(n).normalize(),i=n.cross(o);return f.fromRows([o.x,o.y,o.z,-o.dot(t)],[i.x,i.y,i.z,-i.dot(t)],[n.x,n.y,n.z,-n.dot(t)],[0,0,0,1])}static perspective(t,s,e,n){const o=1/Math.tan(t*Math.PI/360);return f.fromRows([o/s,0,0,0],[0,o,0,0],[0,0,(n+e)/(e-n),2*n*e/(e-n)],[0,0,-1,0])}static viewport(t,s,e,n){return f.fromRows([e/2,0,0,t+e/2],[0,-n/2,0,s+n/2],[0,0,1,0],[0,0,0,1])}static translate(t){return f.fromRows([1,0,0,t.x],[0,1,0,t.y],[0,0,1,t.z],[0,0,0,1])}static scale(t){return f.fromRows([t.x,0,0,0],[0,t.y,0,0],[0,0,t.z,0],[0,0,0,1])}static rotateX(t){const s=Math.cos(t),e=Math.sin(t);return f.fromRows([1,0,0,0],[0,s,-e,0],[0,e,s,0],[0,0,0,1])}static rotateY(t){const s=Math.cos(t),e=Math.sin(t);return f.fromRows([s,0,e,0],[0,1,0,0],[-e,0,s,0],[0,0,0,1])}static rotateZ(t){const s=Math.cos(t),e=Math.sin(t);return f.fromRows([s,-e,0,0],[e,s,0,0],[0,0,1,0],[0,0,0,1])}static rotateXYZ(t,s,e){const n=this.rotateX(t),o=this.rotateY(s);return this.rotateZ(e).multiply(o).multiply(n)}static TRS(t,s,e){const n=this.translate(t),o=this.rotateXYZ(s.x,s.y,s.z),i=this.scale(e);return n.multiply(o).multiply(i)}}function E(w,t){const s=Array.from({length:w.length},()=>new a(0,0,0));for(const e of t){const n=w[e.v[0]],o=w[e.v[1]],i=w[e.v[2]],r=o.sub(n),p=i.sub(n),d=r.cross(p);for(const g of e.v)s[g]=s[g].add(d)}return s.map(e=>{const n=Math.hypot(e.x,e.y,e.z);return new a(e.x/n,e.y/n,e.z/n)})}function B(w){const t=[],s=[],e=[],n=[],o=w.split(`
`);for(const l of o){const M=l.trim();if(!M||M.startsWith("#"))continue;const y=M.split(/\s+/);switch(y[0]){case"v":t.push(new a(+y[1],+y[2],+y[3]));break;case"vt":s.push(new v(+y[1],1-+y[2]));break;case"vn":{const m=+y[1],h=+y[2],u=+y[3],c=Math.hypot(m,h,u)||1;e.push(new a(m/c,h/c,u/c));break}case"f":{const m=[],h=[],u=[];for(const c of y.slice(1)){const[x,R,D]=c.split("/");x&&m.push(parseInt(x)-1),R&&h.push(parseInt(R)-1),D&&u.push(parseInt(D)-1)}if(m.length<3)break;for(let c=1;c<m.length-1;c++)n.push({v:[m[0],m[c],m[c+1]],vt:h.length?[h[0],h[c],h[c+1]]:void 0,vn:u.length?[u[0],u[c],u[c+1]]:void 0});break}}}if(e.length===0){const l=E(t,n);e.push(...l);for(const M of n)M.vn=[...M.v]}let i=new a(1/0,1/0,1/0),r=new a(-1/0,-1/0,-1/0);for(const l of t)i=new a(Math.min(i.x,l.x),Math.min(i.y,l.y),Math.min(i.z,l.z)),r=new a(Math.max(r.x,l.x),Math.max(r.y,l.y),Math.max(r.z,l.z));const p=i.add(r).scale(.5),d=r.sub(i),g=Math.max(d.x,d.y,d.z),b=g>0?1/g:1;for(let l=0;l<t.length;l++)t[l]=t[l].sub(p).scale(b);return new F(t,s,e,n)}class F{constructor(t,s,e,n){this.vertices=t,this.texCoords=s,this.normals=e,this.faces=n}nfaces(){return this.faces.length}nvertices(){return this.vertices.length}getVert(t,s){return s===void 0?this.vertices[t]:this.vertices[this.faces[t].v[s]]}getUV(t,s){const e=this.faces[t];return!e.vt||e.vt[s]===void 0?new v(0,0):this.texCoords[e.vt[s]]}getNormal(t,s){const e=this.faces[t];if(!e.vn)throw new Error("No normals");return this.normals[e.vn[s]]}sampleDiffuse(t){return{r:128,g:128,b:128,a:255}}}class k{constructor(t){this.settings={ctx:null},this.settings.ctx=t.ctx}createImageFromContext(t,s){if(!this.settings.ctx){console.error("CTXImage > CTX is null ");return}return this.settings.ctx.createImageData(t,s)}}let C;function N(w,t){C=new Float32Array(w*t),C.fill(-1e3)}function X(w,t,s,e,n,o){const i=[t[0].scale(1/t[0].w),t[1].scale(1/t[1].w),t[2].scale(1/t[2].w)],r=i.map(z=>{const m=w.viewport.multiplyVector4(z);return new v(m.x,m.y)}),p=f.fromRows([r[0].x,r[1].x,r[2].x],[r[0].y,r[1].y,r[2].y],[1,1,1]);if(p.det()<1e-4)return;const[g,b]=[Math.min(r[0].x,r[1].x,r[2].x),Math.max(r[0].x,r[1].x,r[2].x)],[l,M]=[Math.min(r[0].y,r[1].y,r[2].y),Math.max(r[0].y,r[1].y,r[2].y)],y=p.invert();for(let z=Math.max(Math.floor(g),0);z<=Math.min(Math.floor(b),n-1);z++)for(let m=Math.max(Math.floor(l),0);m<=Math.min(Math.floor(M),o-1);m++){const h=y.multiplyVector3(new a(z,m,1)),u=-1e-5;if(h.x<u||h.y<u||h.z<u)continue;const c=new a(h.x/t[0].w,h.y/t[1].w,h.z/t[2].w),x=c.x+c.y+c.z;c.x/=x,c.y/=x,c.z/=x;const R=h.x*i[0].z+h.y*i[1].z+h.z*i[2].z,D=z+m*n;if(R<C[D])continue;const A=s.fragment(c);C[D]=R;const T=(z+m*n)*4;e[T+0]=A.r,e[T+1]=A.g,e[T+2]=A.b,e[T+3]=255}}class S{}class Z extends S{constructor(t,s,e,n,o){super(),this.model=t,this.viewMatrix=s,this.modelViewMatrix=e,this.projectionMatrix=o,this.lightDirection=s.multiplyVector4(new I(n.x,n.y,n.z,0)).normalize(),this.normalMatrix=this.modelViewMatrix.invertTranspose(),this.vertexToFragmentData={uv:[],normals:[],tri:[]}}vertex(t,s){const e=this.model.getNormal(t,s).normalize(),n=new I(e.x,e.y,e.z,1),o=this.model.getVert(t,s),i=new I(o.x,o.y,o.z,1);this.vertexToFragmentData.uv[s]=this.model.getUV(t,s),this.vertexToFragmentData.normals[s]=this.normalMatrix.multiplyVector4(n.normalize()).toVec3();const r=this.modelViewMatrix.multiplyVector4(i);return this.vertexToFragmentData.tri[s]=r.toVec3(),this.projectionMatrix.multiplyVector4(r)}fragment(t){const s=this.vertexToFragmentData.normals[0].scale(t.x).add(this.vertexToFragmentData.normals[1].scale(t.y)).add(this.vertexToFragmentData.normals[2].scale(t.z)).normalize(),e=this.lightDirection.normalize(),n=new I(0,0,-1,0),o=Math.max(0,s.dot(e.toVec3())),i=s.scale(2*o).sub(e.toVec3()).normalize(),r=.3,p=.7*o,d=.5*Math.pow(Math.max(i.dot(n.toVec3()),0),35),g=Math.min(1,r+p+d),b={r:255,g:255,b:255};return{r:Math.min(255,b.r*g),g:Math.min(255,b.g*g),b:Math.min(255,b.b*g),a:255}}}function P(w,t,s,e,n,o,i){s=s||800,e=e||800;const r=new a(1,1,1).normalize();let p=new a(5,0,-5);const d=new a(0,0,0),g=new a(0,1,0),b=V.TRS(n||new a(0,0,0),o||new a(0,0,0),i||new a(1,1,1)),l=V.lookAt(p,d,g),M=l.multiply(b),y=V.viewport(0,0,s,e),z=V.perspective(20,1,.1,100);console.log("Projection matrix:",z);const h=new k({ctx:w}).createImageFromContext(s,e),u=h.data,c=new Z(t,l,M,r,z);N(s,e);for(let x=0;x<u.length;x+=4)u[x]=22,u[x+1]=22,u[x+2]=22,u[x+3]=255;for(let x=0;x<t.faces.length;x++){const R=[c.vertex(x,0),c.vertex(x,1),c.vertex(x,2)];X({viewport:y},R,c,u,s,e)}w.putImageData(h,0,0)}export{a as V,B as p,P as r};
